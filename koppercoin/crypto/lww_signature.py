"""
Implementation of LWW-signatures as described in
https://lab.getmonero.org/pubs/MRL-0005.pdf
https://bitcointalk.org/index.php?topic=972541.msg10619684#msg10619684
"""

import hashlib
import os
import random
import binascii
from koppercoin.crypto import ietf_ed25519


def keygen():
    """Returns a keypair (secret, public) for use with LWW-signatures."""
    secret = binascii.hexlify(os.urandom(32)).decode()
    public = secret_to_public(secret)
    return (secret, public)


def sha512_modp(s):
    return int.from_bytes(
            hashlib.sha512(s).digest(), "little") % (ietf_ed25519.p)


def secret_to_public(secret):
    """Given a secret key this returns the public key.

    >>> (sec, pub) = keygen()
    >>> secret_to_public(sec) == pub
    True
    """
    secret_as_int = int(secret, 16)
    return binascii.hexlify(
            ietf_ed25519.point_compress(
              ietf_ed25519.point_mul(secret_as_int,
                  ietf_ed25519.G))).decode()


def H_P(P):
    """Hash function returning a point.
    Note that the intuitive idea of computing hash(P)*G is insecure,
    since this is not indifferentiable from a random oracle. We know
    the discrete log and in the case of the LWW-signature we ca
    cancel the anonymity property.

    Instead we compute hash(P)+i for increasing i until it is
    a valid point in the subgroup generated by G (not only on the
    curve).
    This is comparable to the algorithm in Ben Lynn's thesis, where he
    computes H(P) and tries to find a point on the curve with this
    x-coordinate. If he cannot solve for the -coordinate, he increases
    H(P) by 1.

    >>> Neutral = [0,1,1,0]
    >>> H_P(Neutral) # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS
    (4645..., 3154...)
    """
    hash = hashlib.sha256(ietf_ed25519.point_compress(P)).digest()
    point = ietf_ed25519.point_decompress(hash)
    while not point or not ietf_ed25519.point_equal(ietf_ed25519.point_mul(ietf_ed25519.q, point), (0,1,1,0)):
        # repeat if the results of the hash s not a valid point.
        # or if the point is not in the subgroup generated by g.
        # i.e., check that the order of the point is the order of g
        num = int.from_bytes(hash, "little")+1
        hash = int.to_bytes(num, 32, "little")
        point = ietf_ed25519.point_decompress(hash)
    return point


def keyimage(secret):
    """Returns the keyimage of the secret key. This can be used for
    linking two signatures.
    """
    secret_as_int = int(secret, 16)
    public = ietf_ed25519.point_mul(secret_as_int, ietf_ed25519.G)
    solution = ietf_ed25519.point_mul(secret_as_int, H_P(public))
    return ietf_ed25519.point_compress(solution)


def ringsign(public_keys, secret, msg):
    """Returns a LWW-ringsignature.
    public_keys also contains the public key of the signer.
    We return the signature. Since we need always the same ordering on
    the public keys, we will order them before signing.

    >>> public_keys = [keygen()[1] for i in range(3)]
    >>> (sec, pub) = keygen()
    >>> public_keys.append(pub)
    >>> m = "some message"
    >>> signature = ringsign(public_keys, sec, m)
    """
    pub = secret_to_public(secret)
    list.sort(public_keys)
    # we sort the list, since the order is important
    signindex = public_keys.index(pub)
    key_image = keyimage(secret)
    secret_as_int = int(secret, 16)
    # signindex is the index where we start computing the signature
    # aka the index where we know the corresponding privkey
    ringsize = len(public_keys)
    L = [0 for i in range(ringsize)]
    R = [0 for i in range(ringsize)]
    c = [0 for i in range(ringsize)]
    alpha = random.SystemRandom().randrange(ietf_ed25519.p)
    s = [random.SystemRandom().randrange(ietf_ed25519.q) for i in range(ringsize)]
    L[signindex] = ietf_ed25519.point_mul(alpha, ietf_ed25519.G)
    L[signindex] = ietf_ed25519.point_compress(L[signindex])
    R[signindex] = ietf_ed25519.point_mul(alpha,
                                          H_P(ietf_ed25519.point_decompress(
                                              binascii.unhexlify(public_keys[signindex]))))
    R[signindex] = ietf_ed25519.point_compress(R[signindex])
    c[(signindex+1) % ringsize] = sha512_modp(str.encode(msg) +
                                              L[signindex] + R[signindex])
    # iterate through the other indices
    for i in [j % ringsize for j in range(signindex+1, signindex+ringsize)]:
        L[i] = ietf_ed25519.point_add(
                    ietf_ed25519.point_mul(
                        s[i],
                        ietf_ed25519.G),
                    ietf_ed25519.point_mul(
                        c[i],
                        ietf_ed25519.point_decompress(binascii.unhexlify(public_keys[i]))))
        L[i] = ietf_ed25519.point_compress(L[i])
        R[i] = ietf_ed25519.point_add(
                    ietf_ed25519.point_mul(
                        s[i],
                        H_P(ietf_ed25519.point_decompress(binascii.unhexlify(public_keys[i])))),
                    ietf_ed25519.point_mul(
                        c[i],
                        ietf_ed25519.point_decompress(key_image)))
        R[i] = ietf_ed25519.point_compress(R[i])
        c[(i+1) % ringsize] = sha512_modp(str.encode(msg) + L[i] + R[i])
    # stitch the ring together
    s[signindex] = (alpha-c[signindex]*secret_as_int) % ietf_ed25519.q
    signature = (binascii.hexlify(key_image).decode(), c[0], s)
    # validate if the computed signature is correct
    assert(verify(public_keys, msg, signature))
    return signature


def verify(public_keys, msg, signature):
    """Checks if a LWW-ringsignature is valid.

    >>> (sec, pub) = keygen()
    >>> public_keys = [pub]
    >>> m = "some message"
    >>> sig = ringsign(public_keys, sec, m)
    >>> verify(public_keys, m, sig)
    True

    >>> public_keys = [keygen()[1] for i in range(3)]
    >>> (sec, pub) = keygen()
    >>> public_keys.append(pub)
    >>> m = "some message"
    >>> sig = ringsign(public_keys, sec, m)
    >>> verify(public_keys, m, sig)
    True
    >>> verify(public_keys, "wrong message", sig)
    False
    """
    # Typechecks for sig
    assert isinstance(signature, tuple)
    assert isinstance(signature[1], int)
    assert isinstance(signature[2], list)
    # The public_keys need to be sorted, since we need an ordering for
    # verification.
    list.sort(public_keys)
    ringsize = len(public_keys)
    L = [0 for i in range(ringsize)]
    R = [0 for i in range(ringsize)]
    c = [0 for i in range(ringsize+1)]
    (key_image, c[0], s) = signature
    # check if the keyimage is in the subgroup generated by G
    key_image = binascii.unhexlify(key_image)
    if not ietf_ed25519.point_equal(ietf_ed25519.point_mul(ietf_ed25519.q, ietf_ed25519.point_decompress(key_image)), (0,1,1,0)):
        return False
    # recover all the c
    for i in range(ringsize):
        L[i] = ietf_ed25519.point_add(
                    ietf_ed25519.point_mul(
                        s[i],
                        ietf_ed25519.G),
                    ietf_ed25519.point_mul(
                        c[i],
                        ietf_ed25519.point_decompress(binascii.unhexlify(public_keys[i]))))
        L[i] = ietf_ed25519.point_compress(L[i])
        R[i] = ietf_ed25519.point_add(
                    ietf_ed25519.point_mul(
                        s[i],
                        H_P(ietf_ed25519.point_decompress(binascii.unhexlify(public_keys[i])))),
                    ietf_ed25519.point_mul(
                        c[i],
                        ietf_ed25519.point_decompress(key_image)))
        R[i] = ietf_ed25519.point_compress(R[i])
        c[i+1] = sha512_modp(str.encode(msg) + L[i] + R[i])
    # Is the ring closed correctly?
    return c[ringsize] == c[0]


def linked(sig_1, sig_2):
    """Is used to link two signatures. It returns true iff the two
    signatures are from the same signer.

    >>> public_keys = [keygen()[1] for i in range(3)]
    >>> (sec, pub) = keygen()
    >>> public_keys.append(pub)
    >>> m1 = "some message"
    >>> m2 = "message"
    >>> sig1 = ringsign(public_keys, sec, m1)
    >>> sig2 = ringsign(public_keys, sec, m2)
    >>> linked(sig1, sig2)
    True

    >>> public_keys = [keygen()[1] for i in range(3)]
    >>> (sec1, pub1) = keygen()
    >>> (sec2, pub2) = keygen()
    >>> public_keys.extend((pub1, pub2))
    >>> m = "some message"
    >>> sig1 = ringsign(public_keys, sec1, m)
    >>> sig2 = ringsign(public_keys, sec2, m)
    >>> linked(sig1, sig2)
    False
    """
    return sig_1[0] == sig_2[0]
