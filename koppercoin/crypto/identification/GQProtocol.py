"""
This class implements the Homomorphic Identification Protocol of
Guillou-Quisquater

Guillou, Quisquater: "A Practical Zero-Knowledge Protocol Fitted to
Security Microprocessor Minimizing Both Transmission and Memory"
EUROCRYPT '88:
http://dx.doi.org/10.1007/3-540-45961-8_11
"""

from koppercoin.crypto.identification.AbstractIdentificationProtocol import AbstractIdP
import random
import gmpy
import hashlib

class GQProtocol(AbstractIdP):
    @staticmethod
    def setup():
        """Computes a (public, private)-keypair.
        
        >>> (publickey, secretkey) = GQProtocol.setup()
        """
        # generate the primes
        p = random.SystemRandom().getrandbits(1024)
        p = int(gmpy.next_prime(p))
        q = random.SystemRandom().getrandbits(1024)
        q = int(gmpy.next_prime(q))
        n = p*q
        e = 65537
        J = random.SystemRandom().getrandbits(2048)
        while J > n:
            J = random.SystemRandom().getrandbits(2048)
        publickey = (J,e,n)
        # compute the private key
        d = gmpy.invert(e,(p-1)*(q-1))
        B = pow(gmpy.invert(J, n), d, n)
        secretkey = (B, d)
        return (publickey, secretkey)

    @staticmethod
    def comm(publickey, r):
        """
        is a probabilistic algorithm run by the prover to generate
        the first message. The input is the public key and a nonce r.
        The result is an integer and the modulus n, since we need to
        define the ring in which the integer lives.

        >>> import os
        >>> (publickey, secretkey) = GQProtocol.setup()
        >>> GQProtocol.comm(publickey, os.urandom(2048)) # doctest: +ELLIPSIS
        (..., ...)
        """
        (J,e,n) = publickey
        r = int.from_bytes(r, "little")
        return (r, n)

    @staticmethod
    def genChallenge(nonce):
        """returns a challenge."""
        pseudorand = hashlib.sha512(nonce).digest()
        challenge = int.from_bytes(pseudorand, "little")
        return challenge

    @staticmethod
    def resp(publickey, secretkey, r, challenge):
        """is a probabilistic algorithm run by the prover to generate
        the third message. The input is the public key, the secret
        key, as well as a nonce r and the challenge itself, generated
        by genChallenge.
        The result of this function is the response as well as the
        modulus n.

        >>> import os
        >>> (publickey, secretkey) = GQProtocol.setup()
        >>> r = os.urandom(2048)
        >>> challenge = GQProtocol.genChallenge(os.urandom(32))
        >>> GQProtocol.resp(publickey, secretkey, r, challenge) # doctest: +ELLIPSIS
        (..., ...)
        """
        (J,e,n) = publickey
        (B,d) = secretkey
        r = int.from_bytes(r, "little")
        t = (pow(r,d,n) * pow(B, challenge, n)) %n
        return (t, n)

    @staticmethod
    def vrfy(publickey, comm, challenge, resp):
        """is the algorithm used to verify the interaction.

        :param publickey: the public key
        :param comm: is the second message (commit) generated by the prover with comm. 
        :param challenge: the challenge generated by genChallenge.
        :param resp: the response generated by the prover with resp.
        :returns: True iff the interaction is valid.

        >>> import os
        >>> (publickey, secretkey) = GQProtocol.setup()
        >>> r = os.urandom(2048)
        >>> comm = GQProtocol.comm(publickey, r)
        >>> challenge = GQProtocol.genChallenge(os.urandom(32))
        >>> resp = GQProtocol.resp(publickey, secretkey, r, challenge)
        >>> GQProtocol.vrfy(publickey, comm, challenge, resp)
        True

        >>> import os
        >>> (publickey, secretkey) = GQProtocol.setup()
        >>> r = os.urandom(2048)
        >>> comm = GQProtocol.comm(publickey, r)
        >>> challenge = GQProtocol.genChallenge(os.urandom(32))
        >>> r = os.urandom(2048) # For the response we choose a different r
        >>> resp = GQProtocol.resp(publickey, secretkey, r, challenge)
        >>> GQProtocol.vrfy(publickey, comm, challenge, resp)
        False
        """
        (J,e,n) = publickey
        return (pow(J, challenge, n)*pow(resp[0], e, n)) % n == comm[0] % n

    @staticmethod
    def combine_1(c, alpha):
        """Since this is about homomorphic identification protocols,
        we need to have combiner functions. The notation for this is
        straight out of the paper. combine_1 combines the commits comm.
        combine_3 is used to combine the responses Resp.

        Note that there is not combine_2. The challenges are combined
        by a simple linear combination.
        If any of this is not clear, please read the paper mentioned
        above.
        
        The alpha need to be computed by the same publickey. Otherwise
        the alphas are in different rings, since the modulus n is not
        the same. In this case we have undefined behaviour.

        :param c: a coefficient vector to aggregate the commits.
        :param alpha: a list of commits output by comm
        """
        n = alpha[0][1]
        result = 1
        for i in range(len(alpha)):
            comm = alpha[i]
            result = (result * pow(comm[0],c[i],n)) % n
        return (result, n)

    @staticmethod
    def combine_3(c, gamma):
        """combine_3 is used to combine the responses Resp.

        :param c: a coefficient vector to aggregate the commits.
        :param gamma: a list of responses output by Resp.


        >>> import os
        >>> (publickey, secretkey) = GQProtocol.setup()
        >>> rs = [os.urandom(2048) for i in range(3)]
        >>> comms = [GQProtocol.comm(publickey, r) for r in rs]
        >>> challenges = [GQProtocol.genChallenge(os.urandom(32)) for i in range(3)]
        >>> resps = [GQProtocol.resp(publickey, secretkey, rs[i], challenges[i]) for i in range(3)]
        >>> c = [2,3,5]
        >>> aggregated_challenges = sum([c[i] * challenges[i] for i in range(3)])
        >>> GQProtocol.vrfy(publickey, GQProtocol.combine_1(c, comms), aggregated_challenges, GQProtocol.combine_3(c, resps))
        True
        """
        n = gamma[0][1]
        result = 1
        for i in range(len(gamma)):
            resp = gamma[i]
            result = (result * pow(resp[0],c[i],n)) % n
        return (result, n)
