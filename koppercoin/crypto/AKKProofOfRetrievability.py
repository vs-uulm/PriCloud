"""
This class implements Proofs of Retrievability as defined in 

Ateniese, Kamara, Katz: "Proofs of Storage from Homomorphic Identification Protocols",
ASIACRYPT 2009
http://dx.doi.org/10.1007/978-3-642-10366-7_19

This paper describes a general transformation from any linear
authenticator to a proof of retrievability.
This transformation is implemented here.
"""

import hmac
import random
from koppercoin.crypto.AbstractProofOfRetrievability import AbstractProofOfRetrievability
from koppercoin.crypto.identification.LinearAuthenticator import GQLinearAuthenticator, ShoupLinearAuthenticator

def _int_to_bytes(n):
    """Takes an integer and returns a byte-representation"""
    return n.to_bytes((n.bit_length() + 7) // 8, 'little') or b'\0'
    # http://stackoverflow.com/questions/846038/convert-a-python-int-into-a-big-endian-string-of-bytes

def _bytes_to_int(byte):
    """Takes some Bytes and returns an Integer."""
    return int.from_bytes(byte, 'little')

def LinearAuthenticator_to_ProofOfRetrievability(linearauth):
    """
    converts a linear authenticator to a proof of retrievability

    :param linearauth: a linear authenticator
    :returns: a class implementing a proof of retrievability, and inheriting from AbstractProofOfRetrievability

    >>> import os
    >>> (publickey, secretkey) = GQProofOfRetrievability.keygen()
    >>> message = "abcdefghijklmnopqrstuvwxyz"*50
    >>> data = bytes(message, 'utf-8')
    >>> (chunks, authenticators, state) = GQProofOfRetrievability.encode(secretkey, publickey, data)
    >>> challenge = os.urandom(32)
    >>> proof = GQProofOfRetrievability.genproof(publickey, data, authenticators, challenge)
    >>> GQProofOfRetrievability.verify(proof, publickey, challenge, state)
    True

    >>> import os
    >>> (publickey, secretkey) = ShoupProofOfRetrievability.keygen()
    >>> message = "abcdefghijklmnopqrstuvwxyz"*15
    >>> data = bytes(message, 'utf-8')
    >>> (chunks, authenticators, state) = ShoupProofOfRetrievability.encode(secretkey, publickey, data)
    >>> challenge = os.urandom(32)
    >>> proof = ShoupProofOfRetrievability.genproof(publickey, data, authenticators, challenge)
    >>> ShoupProofOfRetrievability.verify(proof, publickey, challenge, state)
    True
    """
    class ProofOfRetrievability(AbstractProofOfRetrievability):
        @staticmethod
        def keygen():
            """Compute a (public, private)-keypair for a proof of
            retrievability.
    
            :returns: tuple -- the (public, private)-keypair.
            """
            return linearauth.gen()
    
        @staticmethod
        def encode(privatekey, publickey, data):
            """encode the data into chunks and generates the
            authenticators, a.k.a. tags, homomorphic linear
            authenticators and a state for identifying the file later
            on.
            In the original AbstractProofOfRetrievability there is a
            filehandle. We misuse the state as filehandle.
    
            :param privatekey: The private key to use.
            :param publickey: The public key to use.
            :param data: The data which should be encoded.
            :returns: tuple -- (fileblocks, authenticators, state)
            """
            chunks = linearauth.splitfile(data, publickey)
            (tags, st) = linearauth.tag(privatekey, publickey, chunks)
            return (chunks, tags, st)
    
        @staticmethod
        def genChallenge(nonce):
            """generates a challenge."""
            return nonce
    
        @staticmethod
        def genproof(publickey, data, authenticators, challenge):
            """This function generates a proof of retrievability.
    
            :param publickey: The public key of the prover.
            :param data: The data over which retrievability should be proven.
            :param authenticators: The authenticators generated by the encode method.
            :param challenge: The challenge, generated by the method genChallenge.
            """
            c = []
            for i in range(len(authenticators)):
                nextcoeff = hmac.new(challenge, _int_to_bytes(i)).digest()
                nextcoeff = _bytes_to_int(nextcoeff) % publickey[-1]
                c.append(nextcoeff)
            chunks = linearauth.splitfile(data, publickey)
            tau = linearauth.auth(publickey, chunks, authenticators, c)
            mu = sum([c[i]*_bytes_to_int(chunks[i]) for i in range(len(chunks))])
            return (tau, mu)
    
        @staticmethod
        def verify(proof, publickey, challenge, state):
            """verifies a proof of retrievability.
            Again we misuse the filehandle as state information.
    
            :param proof: The proof of retrievability.
            :param publickey: The publickey of the prover.
            :param challenge: the challenge used in the generation of the proof.
            :param state: The state used for the proof
            :returns: Bool -- True iff the proof is valid.
            """
            (tau, mu) = proof
            num_chunks = state[1]
            c = []
            for i in range(num_chunks):
                nextcoeff = hmac.new(challenge, _int_to_bytes(i)).digest()
                nextcoeff = _bytes_to_int(nextcoeff) % publickey[-1]
                c.append(nextcoeff)
            return linearauth.vrfy(publickey, state, mu, c, tau)

    return ProofOfRetrievability # return the whole class


GQProofOfRetrievability = LinearAuthenticator_to_ProofOfRetrievability(GQLinearAuthenticator)
"""
This class is the result of applying the transformation from a
homomorphic linear authenticator to a Proof of retrievability to the
GQ linear authenticator.
"""

ShoupProofOfRetrievability = LinearAuthenticator_to_ProofOfRetrievability(ShoupLinearAuthenticator)
"""
This class is the result of applying the transformation from a
homomorphic linear authenticator to a Proof of retrievability to the
Shoup linear authenticator.
"""
