"""
This class implements Proofs of Retrievability as defined in 

Ateniese, Kamara, Katz: "Proofs of Storage from Homomorphic Identification Protocols",
ASIACRYPT 2009
http://dx.doi.org/10.1007/978-3-642-10366-7_19

This paper describes a general transformation from any linear
authenticator to a proof of retrievability.

Basically this file does the same as AKKProofOfRetrievability but
directly and without all the classes and transformations.
"""

import hmac
import random
import hashlib
import gmpy
import json
from pypbc import *
from koppercoin.crypto.AbstractProofOfRetrievability import AbstractProofOfRetrievability

def _int_to_bytes(n):
    """Takes an integer and returns a byte-representation"""
    return n.to_bytes((n.bit_length() + 7) // 8, 'little') or b'\0'
    # http://stackoverflow.com/questions/846038/convert-a-python-int-into-a-big-endian-string-of-bytes

def _bytes_to_int(byte):
    """Takes some Bytes and returns an Integer."""
    return int.from_bytes(byte, 'little')


class GQProofOfRetrievability():
    """
    This class is the result of applying the transformations
    Identification Protocol -> Linear Authenticator -> Proof of
    Retrievability
    to the GQ protocol.

    >>> import os
    >>> (publickey, secretkey) = GQProofOfRetrievability.keygen()
    >>> message = "abcdefghijklmnopqrstuvwxyz"*50
    >>> data = bytes(message, 'utf-8')
    >>> (chunks, authenticators, state) = GQProofOfRetrievability.encode(secretkey, publickey, data)
    >>> challenge = os.urandom(32)
    >>> proof = GQProofOfRetrievability.genproof(publickey, data, authenticators, challenge)
    >>> GQProofOfRetrievability.verify(proof, publickey, challenge, state)
    True
    """
    @staticmethod
    def keygen():
        """Compute a (public, private)-keypair for a proof of
        retrievability.

        :returns: tuple -- the (public, private)-keypair.
        """
        # generate the primes
        p = random.SystemRandom().getrandbits(1024)
        p = int(gmpy.next_prime(p))
        q = random.SystemRandom().getrandbits(1024)
        q = int(gmpy.next_prime(q))
        n = p*q 
        e = 65537
        J = random.SystemRandom().getrandbits(2048)
        while J > n:
            J = random.SystemRandom().getrandbits(2048)
        publickey = (J,e,n)
        # compute the private key
        d = gmpy.invert(e,(p-1)*(q-1))
        secretkey = (pow(gmpy.invert(J, n), d, n), d)
        return (publickey, secretkey)

    @staticmethod
    def encode(privatekey, publickey, data):
        """encode the data into chunks and generates the
        authenticators, a.k.a. tags, homomorphic linear
        authenticators and a state for identifying the file later
        on.
        In the original AbstractProofOfRetrievability there is a
        filehandle which corresponds to our state.

        :param privatekey: The private key to use.
        :param publickey: The public key to use.
        :param data: The data which should be encoded.
        :returns: tuple -- (fileblocks, authenticators, state)
        """
        (J,e,n) = publickey
        (B,d) = privatekey
        chunks = GQProofOfRetrievability._splitfile(data, publickey)
        st = (random.SystemRandom().getrandbits(32), len(chunks))
        tags = []
        for i in range(len(chunks)):
            rand = hmac.new(str.encode(json.dumps(st)), _int_to_bytes(i), digestmod=hashlib.sha256).digest()
            r = int.from_bytes(rand, "little")
            t = (pow(r,d,n) * pow(B, _bytes_to_int(chunks[i]), n)) %n
            tags.append(t)
        return (chunks, tags, st)

    @staticmethod
    def _splitfile(data, publickey):
        """split the data in chunks"""
        # determine the size of a chunk
        chunksize = (publickey[-1].bit_length() + 7) // 8
        chunks = []
        # compute the chunks
        for j in range(0, len(data), chunksize):
            chunks.append(data[j: j+chunksize])
        return chunks

    @staticmethod
    def genChallenge(nonce):
        """generates a challenge."""
        return nonce

    @staticmethod
    def genproof(publickey, data, authenticators, challenge):
        """This function generates a proof of retrievability.

        :param publickey: The public key of the prover.
        :param data: The data over which retrievability should be proven.
        :param authenticators: The authenticators generated by the encode method.
        :param challenge: The challenge, generated by the method genChallenge.
        """
        (J,e,n) = publickey
        chunks = GQProofOfRetrievability._splitfile(data, publickey)
        tau = 1
        mu = 0
        for i in range(len(authenticators)):
            c = hmac.new(challenge, _int_to_bytes(i), digestmod=hashlib.sha256).digest()
            c = _bytes_to_int(c) % n
            tau = (tau * pow(authenticators[i],c,n)) % n
            mu = mu + c * _bytes_to_int(chunks[i])
        return (tau, mu)

    @staticmethod
    def verify(proof, publickey, challenge, state):
        """verifies a proof of retrievability.

        :param proof: The proof of retrievability.
        :param publickey: The publickey of the prover.
        :param challenge: the challenge used in the generation of the proof.
        :param state: The state used for the proof
        :returns: Bool -- True iff the proof is valid.
        """
        (tau, mu) = proof
        num_chunks = state[1]
        (J,e,n) = publickey
        comm = 1
        for i in range(num_chunks):
            c = hmac.new(challenge, _int_to_bytes(i), digestmod=hashlib.sha256).digest()
            c = _bytes_to_int(c) % n
            rand = hmac.new(str.encode(json.dumps(state)), _int_to_bytes(i), digestmod=hashlib.sha256).digest()
            r = _bytes_to_int(rand) % n
            comm = (comm * pow(r,c,n)) %n
        return (pow(J, mu, n)*pow(tau, e, n)) % n == comm


class ShoupProofOfRetrievability():
    """
    This class is the result of applying the transformations
    Identification Protocol -> Linear Authenticator -> Proof of
    Retrievability
    to the Shoup protocol

    >>> import os
    >>> (publickey, secretkey) = ShoupProofOfRetrievability.keygen()
    >>> message = "abcdefghijklmnopqrstuvwxyz"*15
    >>> data = bytes(message, 'utf-8')
    >>> (chunks, authenticators, state) = ShoupProofOfRetrievability.encode(secretkey, publickey, data)
    >>> challenge = os.urandom(32)
    >>> proof = ShoupProofOfRetrievability.genproof(publickey, data, authenticators, challenge)
    >>> ShoupProofOfRetrievability.verify(proof, publickey, challenge, state)
    True
    """
    @staticmethod
    def keygen():
        """Compute a (public, private)-keypair for a proof of
        retrievability.

        :returns: tuple -- the (public, private)-keypair.
        """
        # generate the primes
        p = 0
        while p % 4 != 3:
            p = random.SystemRandom().getrandbits(1024)
            p = int(gmpy.next_prime(p))
        q = 4
        while q % 4 != 3:
            q = random.SystemRandom().getrandbits(1024)
            q = int(gmpy.next_prime(q))
        n = p*q
        # search for a quadratic residue mod n
        y = random.SystemRandom().getrandbits(1024) % n
        y = pow(y,2,n)
        publickey = (y, n)
        secretkey = (p, q)
        return (publickey, secretkey)

    @staticmethod
    def encode(privatekey, publickey, data):
        """encode the data into chunks and generates the
        authenticators, a.k.a. tags, homomorphic linear
        authenticators and a state for identifying the file later
        on.
        In the original AbstractProofOfRetrievability there is a
        filehandle which corresponds to our state.

        :param privatekey: The private key to use.
        :param publickey: The public key to use.
        :param data: The data which should be encoded.
        :returns: tuple -- (fileblocks, authenticators, state)
        """
        def modular_sqrt(a, p, q, s, t):
            """returns the root of a mod pq which is a gain a
            quadratic residue. If a is not a root, it computes the
            root of -a. If -a is also not a root, we have undefined
            behavior. p and q need to be 3 mod 4.
            s and t are integers such that sp+tq = 1
            """
            # Since p,q = 3 mod 4, a root mod p is just pow(a, (p + 1) / 4, p)
            # but we need to use the chinese remainder theorem to lift
            # if to mod n
            # compute mod p
            ap = a % p
            ap = pow(a, (p + 1) // 4, p)
            # choose the one which is a quadratic residue
            if gmpy.jacobi(ap,p) <= 0:
                ap = (p - ap) % p
            # compute mod q
            aq = a % q
            aq = pow(a, (q + 1) // 4, q)
            # choose the one which is a quadratic residue
            if gmpy.jacobi(aq,q) <= 0:
                aq = (q - aq) % q
            # we know s, t, such that sp+tq = 1
            # so the solution is simply ap*t*q + aq*s*p
            return ap*t*q+aq*s*p
        chunks = ShoupProofOfRetrievability._splitfile(data, publickey)
        st = (random.SystemRandom().getrandbits(32), len(chunks))
        tags = []
        (y, n) = publickey
        (p, q) = privatekey
        s = gmpy.invert(p,q)
        t = gmpy.invert(q,p)
        for i in range(len(chunks)):
            challenge = _bytes_to_int(chunks[i])
            rand = hmac.new(str.encode(json.dumps(st)), _int_to_bytes(i), digestmod=hashlib.sha256).digest()
            rand = pow(int.from_bytes(rand, "little"), 2, n)
            # We compute a random 2^(3*5)th root of +- rand * y ^challenge, where
            # the sign is chosen such that a root exists.
            base = rand * pow(y, challenge, n)
            # Choose the sign accordingly
            if gmpy.jacobi(base, n) <= 0:
                base = (n - base) % n
            for i in range(3*5): # 5 is the security parameter
                # In this loop we compute modular roots
                base = modular_sqrt(base, p, q, s, t)
            tags.append(base)
        return (chunks, tags, st)

    @staticmethod
    def _splitfile(f, publickey):
        # determine the size of a chunk
        chunksize = (publickey[-1].bit_length() + 7) // 8
        chunks = []
        for j in range(0, len(f), chunksize):
            chunks.append(f[j: j+chunksize])
        return chunks

    @staticmethod
    def genChallenge(nonce):
        """generates a challenge."""
        return nonce

    @staticmethod
    def genproof(publickey, data, authenticators, challenge):
        """This function generates a proof of retrievability.

        :param publickey: The public key of the prover.
        :param data: The data over which retrievability should be proven.
        :param authenticators: The authenticators generated by the encode method.
        :param challenge: The challenge, generated by the method genChallenge.
        """
        (y, n) = publickey
        tau = 1
        mu = 0
        chunks = ShoupProofOfRetrievability._splitfile(data, publickey)
        for i in range(len(authenticators)):
            c = hmac.new(challenge, _int_to_bytes(i), digestmod=hashlib.sha256).digest()
            c = _bytes_to_int(c) % n
            tau = (tau * pow(authenticators[i],c,n)) % n
            mu = mu + c * _bytes_to_int(chunks[i])
        return (tau, mu)

    @staticmethod
    def verify(proof, publickey, challenge, state):
        """verifies a proof of retrievability.

        :param proof: The proof of retrievability.
        :param publickey: The publickey of the prover.
        :param challenge: the challenge used in the generation of the proof.
        :param state: The state used for the proof
        :returns: Bool -- True iff the proof is valid.
        """
        (y, n) = publickey
        (tau, mu) = proof
        num_chunks = state[1]
        comm = 1
        for i in range(num_chunks):
            c = hmac.new(challenge, _int_to_bytes(i), digestmod=hashlib.sha256).digest()
            c = _bytes_to_int(c) % n
            rand = hmac.new(str.encode(json.dumps(state)), _int_to_bytes(i), digestmod=hashlib.sha256).digest()
            rand = pow(int.from_bytes(rand, "little"), 2, n)
            comm = (comm * pow(rand,c,n)) % n
        lhs = pow(tau, pow(2,(3*5)), n)
        rhs = (comm * pow(y, mu, n)) % n
        if lhs == rhs or lhs == (n-rhs) % n:
            return True
        else:
            return False


class SWProofOfRetrievability(AbstractProofOfRetrievability):
    """
    Class for the Proof of Retrievability according to Shacham and Waters. The variables are
    named according to the paper.
    "Compact Proofs of Retrievability"
    J. Cryptology, 26(3):442–83, Jul. 2013.
    http://cseweb.ucsd.edu/~hovav/papers/sw13.html
    
    We made some modifications to be comparable with the PoRs generated by
    the transformation of Ateniese et al. In particular we set the
    'compression' parameter s = 1
    We store the length of the file in the state, as opposed to
    signing it and appending it.

    >>> import os
    >>> (publickey, secretkey) = SWProofOfRetrievability.keygen()
    >>> message = "abcdefghijklmnopqrstuvwxyz"*50
    >>> data = bytes(message, 'utf-8')
    >>> (chunks, authenticators, state) = SWProofOfRetrievability.encode(secretkey, publickey, data)
    >>> challenge = os.urandom(32)
    >>> proof = SWProofOfRetrievability.genproof(publickey, data, authenticators, challenge)
    >>> SWProofOfRetrievability.verify(proof, publickey, challenge, state)
    True
    """
    _sectorsize_prime = 3791242500069317880783694867506682282365894381307738872324659796721
    # _sectorsize_prime is the prime number p
    _sectorsize = 27
    # since splitting the file in parts of exactly p involves division
    # with remainder of big numbers, which is too slow (yes, I had it
    # implemented) we split the file in parts of multiple bytes.
    # How many bytes should we take? The biggest amount of bytes where the
    # numbers which can be represented are smaller than _sectorsize_prime
    # this number is _sectorsize
    _stored_params = """type f
    q 102211695604069718983498660484838124439154634217492858835280710159724969038960466306786659860346915646711244501222559761637565218087799
    r 102211695604069718983498660484838124439154634217492858835280710159714859058960284816863659729689254234307707069703525418830189356937873
    b 38921215998085487909578322611452695784716056866967068864474907014632882247324723891226765493448226405895006006694858887164802737709901
    beta 1801174012713405906987767275872823955449053607192666454796166887274347403660135510031333913712943650806647184977269979213691585584048
    alpha0 34222075645261775787500175386371728996944314538295461076367772636979981973580948207981521064340212640962635723121463777643434112707919
    alpha1 98727623969956975061805659246476455513316763886830212494749847630390650257739251338607514796841964074225082883985415727045797468325974
    """
    _params = Parameters(param_string=_stored_params)
    _pairing = Pairing(_params)
    # These parameters were generated by libpcs genfparam 448.
    # The manual of libpbc says that Type A pairings are the fastest,
    # but this is only the case for the pairing function. For our
    # purpose it is more important that operations in the groups are
    # fast. That is why we choose a Type f pairing.
    # We assume that generic discrete log algorithms are infeasible in
    # groups of order r, and finite field discrete log algorithms are
    # infeasible in finite fields of order q^12. See the doc for
    # libpbc for more information.
    # NIST (SP 800-57 secteion 5.6.1) say we need 224 bit groups for
    # 112 bit security. But this does not take into account (Kim,
    # Barbulescu, Crypto 16). So we need to double this.
    # r is approx 445 bits long
    @staticmethod
    def keygen():
        """returns a (public, private)-keypair
        """
        sk = Element.random(SWProofOfRetrievability._pairing, Zr)
        generator_G2 = Element.random(SWProofOfRetrievability._pairing, G2)
        generator_G1 = Element.random(SWProofOfRetrievability._pairing, G1)
        pk = (generator_G2, generator_G2**sk, generator_G1)
        return (pk, sk)

    @staticmethod
    def _splitfile(data):
        """splits the data"""
        # split the file in sectors
        chunksize = SWProofOfRetrievability._sectorsize
        chunks = []
        for j in range(0, len(data), chunksize):
            chunks.append(data[j: j+chunksize])
        return chunks

    @staticmethod
    def encode(privatekey, publickey, data):
        """encodes the data into chunks and generates the
        authenticators and the filehandle.
        """
        chunks = SWProofOfRetrievability._splitfile(data)
        # split the file
        (g, gx, u) = publickey
        st = (random.SystemRandom().getrandbits(32), len(chunks))
        # generate one authenticator per block
        authenticators = []
        for i in range(len(chunks)):
            hashval = Element.from_hash(SWProofOfRetrievability._pairing, G1, hmac.new(str.encode(json.dumps(st)), _int_to_bytes(i), digestmod=hashlib.sha256).digest())
            authenticators.append((hashval * (u**_bytes_to_int(chunks[i]))) ** privatekey)
        return (chunks, authenticators, st)

    @staticmethod
    def genChallenge(nonce):
        """Generates a challenge.
        """
        return nonce

    @staticmethod
    def genproof(publickey, data, authenticators, challenge):
        """generates a proof of retrievability.
        """
        # split the file
        chunks = SWProofOfRetrievability._splitfile(data)
        tau = Element.one(SWProofOfRetrievability._pairing, G1)
        mu = 0
        for i in range(len(chunks)):
            c = hmac.new(challenge, _int_to_bytes(i), digestmod=hashlib.sha256).digest()
            c = _bytes_to_int(c)
            tau *= authenticators[i] ** c
            mu += _bytes_to_int(chunks[i]) * c
        return (tau, mu)

    @staticmethod
    def verify(proof, publickey, challenge, state):
        """verifies a proof of retrievability.
        """
        (tau, mu) = proof
        (g, gx, u) = publickey
        num_chunks = state[1]
        pairing = SWProofOfRetrievability._pairing
        hashval = Element.one(pairing, G1)
        for i in range(num_chunks):
            hashval *= Element.from_hash(pairing, G1, hmac.new(str.encode(json.dumps(state)), _int_to_bytes(i), digestmod=hashlib.sha256).digest()) ** _bytes_to_int(hmac.new(challenge, _int_to_bytes(i), digestmod=hashlib.sha256).digest())
        LHS = pairing.apply(hashval * (u**mu) , gx)
        # RHS = e(sigma, generator)
        RHS = pairing.apply(tau, g)
        if RHS == LHS:
            return True
        return False
